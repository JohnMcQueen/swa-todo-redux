# Todo App Brown Bag Session \#2

## Creating Actions
The process for adding a new action involves the following steps
1. Add a new type for the action to `types.js`
2. Add the action creator with `actions.js`
3. Add a new switch case in `reducer.js` that uses the new action type and
updates state according to the action's payload
4. Import the new action creator into the container of the component that will
dispatch the action
5. Add code to the component to fire the new action whenever necessary (via a
    browser event, AJAX request, timer, etc)
6. Dispatch the action and make sure that state is being updated correctly

## Delete Todo Example
1. Add a new key to the object in `src/modules/Todos/types.js`. The new type for
the action to delete todos will be:
```
DELETE_TODO: '@swa-todo-redux/Todos/DELETE_TODO'
```
The `@swa-todo-redux/Todos` namespace prevents collisions when multiple modules
need to export an action with the same name. Remember that the action types are
just strings, and if we forget to namespace our modules then we can have
collisions when `moduleA` dispatches an action with the same type constant as
`moduleB`. A good example is a `SEARCH` action.
2. Add a new function inside of `actions.js` that accepts a single parameter of
the todo ID and returns an object with the `DELETE_TODO` type and `id` payload.
3. Add a new case inside of the function in `reducer.js`. This new case will
update the list of todos by removing the one that matches with the given ID. We
want to create a new copy of the list with the matching todo filtered out.
Reducers should always generate new copies of the data whenever they respond to
an action.
```
case types.DELETE_TODO:
    newState = {
        ...state,
        todos: state.todos.filter(todo => todo.id !== id)
    }
    break;
```
When possible we want to stick to functions like `map` and `filter` that do not
alter the objects they work upon.
4. In `src/components/TodoItem/container.js` import the new action and copy it
into the object created by `mapDispatchToProps`. The existing action '
(`completeTodo`) can be used as the template for this. We will introduce a new
`Redux` method `bindActionCreators` to reduce some of the boiler plate when
connecting actions to components.
5. Add an `onClick` event handler to the `<IconButton>` inside of `TodoItem`. We
just need to call the new function that we added to props inside of the
container.
```
const handleDeleteButtonClick = () => {
    props.deleteTodo(props.todo.id)
};
```
6. Profit

## Asynchronous Actions
To perform asynchronous actions we will be using a piece of third party
middleware known as [redux-thunk](https://github.com/reduxjs/redux-thunk). [This
article](https://medium.com/@gethylgeorge/understanding-how-redux-thunk-works-72de3bdebc50)
goes through the source code and gives an in depth explanation of how this
package works underneath the hood.

The most common asynchronous actions we will be performing are the result of
AJAX requests. We will be using [Axios](https://github.com/axios/axios) to make
our requests and using ES6 Promises to dispatch our series of actions. The
following pattern assumes that the AJAX library returns a promise object
(similar to how the browser based fetch library works).

### AJAX Action Pattern
Assume that we want to fetch a list of todos from a backend service. Lets call
this action `retrieveTodos` and assume that it is called from within a component
whenever the page loads.

I recommend the following pattern for AJAX requests. It involves three discrete
action creators for every request.

* `retrieveTodosInit`
* `retrieveTodosSuccess`
* `retrieveTodosFailure`

1. Dispatch an "init" action that informs the application an AJAX request will
be made. This action will be used to disable fields, begin animations, or
perform any other behavior that should occur when a request is made.
2. Return the promise generated by `Axios`. This will let the `redux-thunk`
middleware know that it should intercept this action.
3. Check the status of the request and throw an error if the request has a bad
status.
4. Grab the response data and send it to the `retrieveTodosSuccess` action
creator. The action creator is responsible for doing any necessary manipulation
to the response data in order to prepare it for the application. This often
includes normalization which we can discuss if we have enough time.
5. If an error is thrown at any time during the request, catch it an dispatch it
within the `retrieveTodosFailure` action creator.

This pattern is used inside of `modules/Todos/actions/retrieveTodos.js`.

## Testing Actions
### Coming Soon!

## Normalization
Data normalization in Redux is similar to how it works in a relational DB. We
want to avoid data duplication by flattening deeply nested structures. This
todo application has no nested data, but we can still demonstrate the basic
steps required.
Normalizing data not only prevents duplication, but in the case of React and
Redux it allows us to perform very targeted updates. Our current data structure
for Todo items is an array like this:
```
{
    todos: [{
        completed: false,
        description: 'Some description',
        dueBy: 'January 10th 2019 5:00PM',
        id: 1
    }]
}
```
The `<TodoList />` receives this data and passes each todo item in the list as a
props to a `<TodoItem />` which renders the data on screen. The downside to this
approach is that updates to a single item in the list (such as completing a
todo) forces the `<TodoList />` to perform a new render even though it is not
responsible for rendering the checkbox. We would like to target the specific
`<TodoItem />` which contains the updated Todo. To achieve this we will first
split the todo list into a list of IDs and a dictionary of todo entities.
```
{
    todos: [1],
    entities: {
        1: {
            completed: false,
            description: 'Some description',
            dueBy: 'January 10th 2019 5:00PM',
            id: 1
        }
    }
}
```
Now the `<TodoList />` receives a list of IDs instead of a list of todos. It
passes the ID as a prop to the child. We need to create a selector that is
capable of receiving this ID and returning the matching todo entity. We will
use this function inside of the `<TodoItem />` container.
```
// src/modules/Todos/reducer.js
getTodoById = (state, id) => state.todos[id];

// src/components/TodoItem/container.js
import {getTodoById} from '../../modules/Todos'

mapStateToProps = (state, ownProps) => ({
    todo: getTodoById(state, ownProps.todoId)
});
```
When an individual todo entity gets updated, the `<TodoList />` will not see any
difference in its props because the list of todo IDs is the same. Only the
`<TodoItem />` that contains the impacted todo entity will receive an update.

As our data becomes more deeply nested (such as flight data) we receive even
bigger benefits from data normalization. We reduce our overall data footprint,
updates become easier because there is only one source of truth, there is no
need for components to be aware of the complicated structure of their data, and
finding data about specific entities becomes more performant since dictionary
lookups are much faster than searching an array.
